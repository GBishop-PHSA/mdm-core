import java.lang.management.ManagementFactory
import java.lang.management.RuntimeMXBean
import java.util.concurrent.TimeUnit

buildscript {
    repositories {
        mavenLocal()
        maven { url 'https://jenkins.cs.ox.ac.uk/artifactory/plugins-snapshot' }
        maven { url 'https://jenkins.cs.ox.ac.uk/artifactory/plugins-release' }
        jcenter()

    }
    dependencies {
        classpath "ox.softeng.gradle:oxbrcinformatics-gradle-plugins:$oxbrcinformaticsGradlePluginsVersion"

        // The version of spring-core included is 3.1.3.RELEASE which is incompatible with the grails-gradle-plugin used by all the
        // the Grails modules and causes issues when trying to run-app therefore we exclude it
        classpath("gradle.plugin.com.hierynomus.gradle.plugins:license-gradle-plugin:$licenseGradlePluginVersion") {
            exclude group: 'org.springframework', module: 'spring-core'
        }
        // However without spring-core the license plugin won't work so we need to include it at the top level
        // this version will need to be kept inline with Grails' spring-core
        classpath "org.springframework:spring-core:$licenseGradlePluginSpringCoreOverrideVersion"
    }
    configurations.all {
        // check for updates every build
        resolutionStrategy.cacheChangingModulesFor 0, TimeUnit.SECONDS
    }
}

plugins {
    id 'maven'
    id "com.jfrog.artifactory" version "4.15.2"
    id 'maven-publish'
}

apply plugin: 'ox.softeng.ox-brc-base'
apply plugin: "com.github.hierynomus.license"

task unitTest() {
    group 'testing'
    description = 'Catch task for unit test'
}

task integrationTest() {
    group 'testing'
    description = 'Catch task for integration test'
    mustRunAfter unitTest
}

task jacocoRootReport() {
    group 'reporting'
    description = 'Catch task for all jacoco root report'
    mustRunAfter unitTest, integrationTest
}

task staticCodeAnalysis() {
    group 'reporting'
    description = 'Catch task for all SCA tasks'
    mustRunAfter unitTest, integrationTest, jacocoRootReport
}

check {
    dependsOn unitTest, integrationTest, jacocoRootReport, staticCodeAnalysis
}

task('sysProps') {
    group 'help'
    doLast {
        logger.quiet('{}', System.properties.collect { "${it.key}:${it.value}" }.sort().join('\n'))
    }
}

task('jvmArgs') {
    group 'help'
    doLast {
        RuntimeMXBean runtimeMxBean2 = ManagementFactory.getRuntimeMXBean()
        logger.quiet('{}', runtimeMxBean2.getInputArguments().join('\n'))
    }
}


logger.quiet(
    "Available processors ${Runtime.runtime.availableProcessors()}. Max Unit Test Parallel Forks " +
    "${Runtime.runtime.availableProcessors().intdiv(2) ?: 1}")

subprojects {
    tasks.register("bomProperties") {
        group = 'Introspection'
        description = 'Print properties from all BOMs'
        doLast {
            if (project.hasProperty('dependencyManagement')) {
                Map imported = dependencyManagement.importedProperties
                logger.quiet 'Project :: {}\n  {}', project.name, imported.collect { k, v -> "$k:$v" }.sort().join('\n  ')
            }
        }
    }
    afterEvaluate {
        project.tasks.withType(Test) {
            ignoreFailures = System.getenv().containsKey('JENKINS')
        }
    }
}

/*
Task to archive up all reports that exist in the project and sub-project
 */
task reportsArchive(type: Tar) {
    archiveClassifier = 'reports'
    if (System.getenv('TRAVIS')) {
        archiveVersion = System.getenv('TRAVIS_JOB_NUMBER')
    }
    from("$buildDir/reports") {
        into "reports/ROOT"
    }

    doLast {
        println archiveFileName.get()
    }
}

task rootTestReport(type: TestReport) {
    group = 'reporting'
    destinationDir = file("${buildDir}/reports/tests")
    testResultDirs = files("${buildDir}/test-results")
    FileCollection testResultContentDir = files("${buildDir}/test-results")
    outputs.upToDateWhen { false }

    doFirst {
        (testResultContentDir.getAsFileTree().visit { FileVisitDetails details ->
            if (details.directory && details.name == 'binary') {
                logger.info("Reporting on ${details.path}")
                reportOn files(details.file)
            }
        })
    }
}

subprojects {

    apply plugin: 'com.github.hierynomus.license'

    license {
        header = file("${rootDir}/NOTICE")
        excludes([
            '**/*.gson',
            '**/*.yml',
            '**/META-INF/**',
            '**/*.txt',
            '**/*.json',
            '**/*.gml',
            '**/*.jpeg',
            '**/*.png',
            '**/*.xml',
            '**/*.sql'
        ])
    }

    String pName = project.name
    rootProject.tasks.reportsArchive {
        from("$buildDir/reports") {
            into "reports/$pName"
        }
        from("$buildDir/logs") {
            into "logs/$pName"
        }
    }

    afterEvaluate {
        project.tasks.withType(Test) { testTask ->
            doLast {
                copy {
                    from project.file("${project.buildDir}/test-results")
                    into rootProject.file("${rootProject.buildDir}/test-results/${project.name}")
                }
            }
        }

        Set<Project> dependencyProjects = collectProjectDependencies(project)
       if(dependencyProjects){
           project.tasks.findByName('install').dependsOn dependencyProjects.collect {it.tasks.findByName('install')}
       }
    }
}

// Custom publishing to allow us to push the reports up to artifactory from travis
if (project.hasProperty('artifactory_user') && project.hasProperty('artifactory_apiKey')) {
    publishing {
        repositories {
            maven {
                url = "${project.artifactory_contextUrl}/build-reports"
                credentials {
                    username = "${project.artifactory_user}"
                    password = "${project.artifactory_apiKey}"
                }
            }
        }
        publications {
            reports(MavenPublication) {
                if (System.getenv('TRAVIS')) {
                    version = System.getenv('TRAVIS_JOB_NUMBER')
                }
                artifact tasks.reportsArchive
            }
        }
    }
}

Set<Project> collectProjectDependencies(Project project) {
    Set<Project> dependencyProjects = new HashSet<>()
    ConfigurationContainer configurations = project.configurations
    Configuration configuration = configurations.findByName('compile')
    if(configuration) {
        DomainObjectSet<ProjectDependency> projectDependencies = configuration.dependencies.withType ProjectDependency
        projectDependencies.forEach {
            dependencyProjects.add(it.dependencyProject)
            dependencyProjects.addAll(collectProjectDependencies(it.dependencyProject))
        }
    }
    configuration = configurations.findByName('implementation')
    if(configuration) {
        DomainObjectSet<ProjectDependency> projectDependencies = configuration.dependencies.withType ProjectDependency
        projectDependencies.forEach {
            dependencyProjects.add(it.dependencyProject)
            dependencyProjects.addAll(collectProjectDependencies(it.dependencyProject))
        }
    }
    dependencyProjects
}